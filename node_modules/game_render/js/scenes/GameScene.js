import Phaser from '../phaser.js';

import constant from '../utils/Constant.js';

import PlayerManager from '../utils/PlayerManager.js';
import BombManager from '../utils/BombManager.js';
import BrickManager from '../utils/BrickManager.js';

import Explosion from '../object/Explosion.js';

export default class GameScene extends Phaser.Scene {

    constructor() {
        super('GameScene');
    }

    init(data) {
        console.log('GameScene', data);
        this.dataGame = data;
    }

    create() {
        // TODO: Draw Score Table
        this.cameras.main.setBackgroundColor('#BCBCBC');

        // TODO: Draw Map from map_data
        let map_data = this.cache.text.get('map_data').split('\n');

        for (let i = 0; i < map_data.length; i++)
            for (let j = 0; j < map_data[i].length; j++) {
                let x = (j * constant.BLOCK_SIZE + constant.BLOCK_SIZE / 2 + constant.ORIGIN_X) * constant.SCALE;
                let y = (i * constant.BLOCK_SIZE + constant.BLOCK_SIZE / 2 + constant.ORIGIN_Y) * constant.SCALE;
                if (i === 0 && j === 0) console.log(y);
                let temp;
                switch (map_data[i][j]) {
                    case '#':
                        temp = this.add.image(x, y, 'wall');
                        temp.setScale(constant.SCALE / 2.5, constant.SCALE / 2.5);
                        break;
                    case '.':
                        temp = this.add.image(x, y, 'grass');
                        temp.setScale(constant.SCALE / 2.5, constant.SCALE / 2.5);
                        break;
                    case 'o':
                        temp = this.add.image(x, y, 'grass');
                        temp.setScale(constant.SCALE / 2.5, constant.SCALE / 2.5);
                        temp = this.add.image(x, y, 'mine');
                        temp.setScale(constant.SCALE / 2.5, constant.SCALE / 2.5);
                        break;
                }
            }

        // TODO: initialize game
        delete this.player_1;
        this.player_1 = new PlayerManager(this, 1, this.dataGame.game[0].player_1);
        delete this.player_2;
        this.player_2 = new PlayerManager(this, 2, this.dataGame.game[0].player_2);
        this.bombsManger = new BombManager();
        this.brickManager = new BrickManager();

        this.runGameTurn(this.dataGame.game[0]);

        this.turn = 0;

        if (constant.INTERVAL != null)
            clearInterval(constant.INTERVAL);
        constant.INTERVAL = setInterval(function () {
            if (this.turn === this.dataGame.game.length) return;
            this.turn += 1;
            if (this.turn < this.dataGame.game.length)
                this.runGameTurn(this.dataGame.game[this.turn]);
            else
                this.endGame();
        }.bind(this), 15);
    }

    endGame() {
        let endMessage;
        switch (this.dataGame.result) {
            case 0:
                endMessage = this.add.image(constant.MAP_WIDTH / 2 * constant.SCALE, constant.MAP_HEIGHT / 2 * constant.SCALE, 'draw');
                break;
            case 1:
                endMessage = this.add.image(constant.MAP_WIDTH / 2 * constant.SCALE, constant.MAP_HEIGHT / 2 * constant.SCALE, 'win');
                break;
            case 2:
                endMessage = this.add.image(constant.MAP_WIDTH / 2 * constant.SCALE, constant.MAP_HEIGHT / 2 * constant.SCALE, 'lose');
                break;
        }
        console.log(endMessage );
        if (endMessage != null) {
            endMessage.setScale(0.2, 0.2);
            endMessage.setPosition(constant.MAP_WIDTH / 2 * constant.SCALE, -100);

            this.tweens.add({
                targets: endMessage,
                x: constant.MAP_WIDTH / 2 * constant.SCALE,
                y: constant.MAP_HEIGHT / 2 * constant.SCALE,
                scaleX: 0.7 * (constant.SCALE / 2.5),
                scaleY: 0.7 * (constant.SCALE / 2.5),
                duration: 1000,
                ease: 'Back.easeOut'
            });
        }
    }

    runGameTurn(dataGame) {
        this.player_1.setData(dataGame.player_1);
        this.player_2.setData(dataGame.player_2);

        this.bombsManger.setBomb(this, dataGame.bombs);

        this.brickManager.setBrick(this, dataGame.bricks);

        dataGame.explosions.forEach(function (item) {
            this.add.existing(new Explosion(this, item.x, item.y, 'explosion_center'));
            for (let i = 1; i <= item.d; i++)
                this.add.existing(new Explosion(this, item.x, item.y + 16 * i, (i === item.d) ? 'explosion_down' : 'explosion_vertical'));
            for (let i = 1; i <= item.u; i++)
                this.add.existing(new Explosion(this, item.x, item.y - 16 * i, (i === item.u) ? 'explosion_up' : 'explosion_vertical'));
            for (let i = 1; i <= item.l; i++)
                this.add.existing(new Explosion(this, item.x - 16 * i, item.y, (i === item.l) ? 'explosion_left' : 'explosion_horizontal'));
            for (let i = 1; i <= item.r; i++)
                this.add.existing(new Explosion(this, item.x + 16 * i, item.y, (i === item.r) ? 'explosion_right' : 'explosion_horizontal'));
        }.bind(this));
    }
}
